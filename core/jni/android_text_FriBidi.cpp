/*
 * Copyright (C) 2011 Iranian Supreme Council of ICT, The FarsiTel Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASICS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define LOG_TAG "FriBidi"
#define DO_NOT_INCLUDE_LOCK 1

#include <utils/Log.h>

#include "jni.h"
#include "utils/misc.h"
#include "android_runtime/AndroidRuntime.h"
#include <nativehelper/JNIHelp.h>

#include <sys/types.h>
#include <dirent.h>
#include <time.h>
#include <openssl/dsa.h>
#include <openssl/engine.h>
#include <openssl/sha.h>
#include <fribidi.h>
#include <fribidi-char-sets.h>

#define PARAGRAPH_DIRECTION_LTR  1
#define PARAGRAPH_DIRECTION_RTL  2
#define PARAGRAPH_DIRECTION_ON   3
#define PARAGRAPH_DIRECTION_WLTR 4
#define PARAGRAPH_DIRECTION_WRTL 5

namespace android {

#ifndef DO_NOT_INCLUDE_LOCK
static unsigned char dsa2560_data[1280] = {
    0x7f,0x40,0x2d,0xd7,0xdd,0x3c,0x7d,0xa7,0x96,0x83,0x21,0xd3,
    0xa2,0xa4,0x4c,0x45,0x4e,0x4b,0x3c,0x25,0x52,0x1c,0xda,0xbe,
    0x40,0x1c,0x19,0x8c,0x25,0x87,0x1a,0x37,0xa4,0xb2,0x6e,0x3a,
    0x71,0x31,0xa3,0xf7,0xa5,0x3c, 0xc,0xb5,0xce,0x18,0x4d,0x51,
    0xce, 0xd,0x6c, 0x0,0x13,0xc2, 0xa,0xd4,0xa7,0x32,0x28,0x88,
    0xfa,0xdd,0x7c,0x5b,0x15,0x21,0x8a,0xb4,0x77,0x73,0x6f,0x45,
    0xf8,0xa5,0xb3,0xec, 0x4,0x9d,0xf0,0x29,0x2e,0x9a,0x1a,0x1c,
    0xe8,0xff,0x40,0x4d,0x53,0x63,0x93,0xec,0x1a, 0x3,0xe0,0xa1,
    0x5f,0x55,0xe2,0x45,0xec,0xf5,0x93,0x6c,0x28,0xda,0xce,0x4e,
    0x8d,0x38,0xd5,0xce,0x5f, 0x0,0xb8,0xcf,0xe3,0x2b,0xa9,0xfc,
    0x6d, 0xa, 0x9,0x3e,0x63,0xce,0x59,0xeb,0xdf,0x20,0x8d, 0xa,
    0xac,0x50,0x4b,0x80,0xc5,0x32,0xe1,0x30,0x64,0x7a,0xe7,0x71,
    0xcf,0xb3,0xb9,0x9a,0xef,0xa5,0xec,0xfe,0x3b,0x3a, 0x8,0x38,
    0x5f,0x12,0x6d,0xf2,0x49,0x9b,0x41,0xaf,0x4f,0xd1,0x48,0xbf,
    0xfd,0xfb,0x8b,0x25,0x46,0xbf,0xf2,0x97,0x85,0xf8,0xe9,0xc0,
    0xcf,0x72,0x42,0xca,0x38, 0x8,0xf2,0x62,0x43,0x9f,0xab,0xb4,
    0x72,0x9d,0xa8,0xa3,0x76,0x67,0xc7,0x77,0x66,0x8c,0x3a,0xa7,
    0x8f,0x37,0xd5,0x57,0x9d,0x6e,0xf7,0xb9,0xf3, 0xb,0xd6,0x16,
    0xa3,0xf0,0x67,0x19,0x50,0xd8,0x81,0xcd,0x2c,0xa2,0xb1,0x43,
     0xa,0x14,0xee,0x90,0xde,0x5d,0xa7,0x85,0xf8,0x9c,0x1e,0xd6,
    0x24,0xd3,0x32,0x81,0x7f,0xcf,0xea,0x70,0x5a,0x80,0x55,0xfc,
    0x14,0x14,0x67,0x74,0x55,0x25,0x1a,0xdc,0xb3,0xcc,0xb8,0xdb,
    0xde,0x48,0x1d,0xd5,0xe8,0x11,0x2f,0x81,0x96, 0x3,0xa1,0x8a,
    0x6c,0x41,0x7d,0x72,0xcd,0xb0,0xdd,0xd5,0x40,0x7c,0x76,0x45,
    0x76,0x9a,0x88,0x6c,0x27,0x3d,0x2f,0xfb,0x8d,0x3a,0xbc,0x4e,
    0xb4,0x5a,0xd8,0xec,0x78,0xdd,0xd4,0x88,0xe3,0xd6,0x47,0xa3,
    0x52,0x17,0xce,0x58,0xae,0x13,0x44,0xd3,0xa9,0x20,0x9d,0xc4,
    0xd5,0x90,0x9b,0x51, 0x0,0xb4,0xf4,0x3d,0xe0,0xa0,0x1f,0xdb,
    0x14,0xa4,0x52,0x70,0x53,0x24, 0xd,0xbc,0x38,0x70,0x48,0x72,
    0xa3,0xfa,0xfa,0xf7,0x84, 0xa,0xe8,0x7f,0x7d,0x97,0x6c,0xe8,
    0xb7,0x27,0x9d,0xef,0x8b,0xbd,0x68,0x3e,0x70,0xfa,0x81,0xb7,
    0xf4,0x5e,0x8d,0x6a,0x12,0xd9,0xfb,0x32,0xe6,0xc8,0xf7,0x86,
    0x35,0x2a, 0xe,0xa0,0xd5,0x2d,0xa1,0x77,0x34,0x95,0x7a, 0xb,
    0xf8,0x22,0x79,0x97,0xf1,0xbc,0xe4,0xae,0xa8,0x66,0xd8,0x87,
    0x8c,0xb9,0xf4,0x1d,0x31,0xa4,0x98,0x12,0x4b,0x1b, 0x8,0xd5,
    0xaf,0xe0,0x2c,0xec,0x77,0x48,0x1f,0xab,0x57,0xa0,0x80,0x6f,
    0xf4,0x7a,0xd9,0x84,0x38,0x8f,0x55,0xab,0xa8,0xb7,0x73,0x8c,
    0x69,0x64,0xa8,0x67,0xaa,0x93,0x67,0xb9, 0x0,0x5b,0xca,0x1b,
    0xcf,0x62,0xfe,0x32,0xa7,0xa0,0x8b,0x6e,0x2f,0x16,0x89,0x8f,
    0xb7,0xf7,0x68,0x4a,0xcb,0xbc,0xa8,0x36,0xf9,0x26,0x3d,0x85,
    0x26,0xc6, 0x0,0x92,0x84,0x7f,0x5f,0xf1,0x5f,0x87,0x2c,0x57,
    0x3e,0xc9,0xbc,0x9d,0x9d,0x17,0x9b,0xe9,0x38,0x1a,0xb1,0x1f,
    0x5d,0xf1,0x9f,0xc3,0x12,0xbc,0xe9,0xa2,0xa9,0x6e,0xd5,0x5b,
    0x6b,0xb9,0x5f,0xd8,0x51,0x37,0xd9,0x41,0x62,0xeb,0x99,0x2b,
    0xe9,0x83,0x6c,0xd8,0x92,0xb8,0x8b,0xe0,0x48,0xfc, 0xf,0xf4,
    0x13,0x75,0x38,0xf3,0xd8,0x6c, 0x2,0x5b,0x2f,0x69,0xdb,0x98,
    0x38, 0xb,0xc5,0x18,0x30,0xb5,0xbf,0xbe,0x67,0xa2,0x73,0x7a,
    0x48, 0xe,0xb8,0x54,0x85,0xe1,0xac,0xb9,0x7a,0xb3,0xde,0x83,
    0xca,0xa4,0x70,0xb0,0x29,0xfa,0xb3,0x43,0xee,0xa2,0xf1,0xd1,
    0x94,0x91,0x87,0xc5,0xe3,0x5d,0x16,0x33,0xab,0xed,0xb9,0xa7,
    0xa1,0xae,0xae,0x12,0xee,0x48,0x16,0x14,0x59,0x21,0xb5,0xfd,
    0x60, 0x0,0x7e,0x60,0xa5,0xfb,0xc9,0x61,0xea,0xde,0x68,0x52,
    0xd5,0xc9,0xfe,0x38,0x55,0x15,0xcd,0x4c,0xa3, 0x0,0x65,0x44,
    0x51,0x9f,0x1a,0x56,0x60,0x1c,0xc0,0xcf,0x47,0x18,0xb3,0xf8,
    0xc6,0xe0,0xdb,0xb3,0x3e,0xb9,0xde,0xd0,0xbb,0xf6,0xa3,0xfb,
    0x99,0x2a,0x6e,0x47,0x84,0xca,0xad,0xf8,0x2f,0x74,0x7f,0x10,
    0xc8,0xb1,0xe1,0xd0,0xc6,0x44,0x1f,0xfa,0x98,0x58,0x6d,0xc2,
    0x9f,0xef,0x28,0x96,0xdc,0x67,0xd4,0x78,0x2f,0xff,0x22,0xa4,
    0x19,0xe4,0x35,0x47,0x6f,0xc8,0xc5,0x1f,0x8c,0xff,0x7f,0xb7,
    0x24,0xce,0x93,0x60, 0x9,0xd5,0x24,0x71,0x7f,0xd0,0x59,0xff,
    0xbe,0xd3,0x72,0xe8,0xfd,0x83,0x25,0x37,0x1a,0x67,0xec,0x80,
    0xf0,0xee,0x1d,0xb9,0x54,0xbd,0x96,0x83,0x3d,0x74,0xcc,0xec,
    0x1a,0xcb,0xa2,0x29,0x47,0xab,0x95,0xee,0xd8,0x63,0x60,0x93,
     0x0,0x22,0x49,0x66,0x51,0x5d,0x6c,0xfe,0xf4,0xe4,0x41,0x91,
    0x32,0x57,0xf5,0xec,0x1c,0xe3,0x1e,0x20,0x3b,0x9c,0x49, 0xd,
    0xa4,0x3e,0x3c,0x7c,0xe6,0x66,0xa8,0xdf,0x69,0x95,0x37,0x73,
    0x68,0x34,0x8e,0xbb,0x46,0xa8, 0x2,0x4d,0xf2,0xc3,0x41,0xb4,
    0xcc,0xae,0x67,0xae, 0x3,0x5b,0x26,0x69,0x88,0x13,0x7a,0x91,
    0x3f,0x62,0x7d,0xac, 0x0,0xe9,0x74,0xd6,0x33,0x8d,0xe4,0x6b,
    0x40,0x5c,0x43,0x39,0xf8,0xe7,0x4b, 0x4,0xdd,0x39,0xce,0xc5,
    0xd6,0x92,0x9e, 0xb, 0x2,0xda,0xe5,0x1c,0x32,0x6e,0x12,0x42,
    0xa5,0xd4,0x1b,0x4e,0x81,0x85,0x36,0xfd,0x20,0x69,0x73,0x95,
    0xda,0x15,0x29,0xdc,0x26,0x30,0xd1,0xd2,0x87,0x27,0x92,0x29,
    0x61,0x20,0x32,0x1e, 0xb,0xb5,0x57,0xea,0x85,0x44,0xe2, 0x7,
    0x1c,0xcd,0x3c,0xc2,0xe6,0x58,0xe6,0x66,0x6e,0xbe,0x35,0x19,
    0xa8,0x8a,0xdd,0xa1,0x73,0x4d,0x64,0x52,0x1a,0xe5,0xe8,0x66,
    0x5c,0x84,0x70, 0xd,0x30,0x81,0x68,0x21,0xd5,0xb2,0x42,0xc3,
    0xf2,0x16,0x13,0x94,0xad,0x35,0xfe,0x89,0xf1, 0x9,0x5f,0xcb,
    0x6c, 0xb,0xb4,0x3e,0x48,0x3a,0xd0,0xb7,0x6f,0x77,0x97, 0x3,
    0xac,0x42, 0xf,0xc0,0x35,0xba,0x7a,0x13,0xc2,0xd1,0xf9,0x24,
    0x52,0x5f,0x82,0xac,0x6a,0xd9,0x3a,0x61,0xc9,0x7f,0xfc,0x55,
     0x5,0xcc,0x3e,0x4d,0x9c,0x2e, 0x3,0x56,0x8b,0x18,0xa9,0x1a,
    0x75,0x5e,0xf4,0x2f,0x2c,0x54, 0x9,0xf9,0xea,0xb8,0x52, 0x5,
    0x8d,0x3e,0xbc,0x57,0x66,0x98,0xa0,0x1e,0xb8,0x4b,0x31,0xfb,
     0xd,0xf1,0xc0,0x32,0x27,0x9c,0x41,0x75,0x6a,0x2e,0xe6,0xcb,
     0x8,0x25,0x10,0x47,0xbc,0x16,0x81,0x9e,0xe6,0xb8,0x8e,0x4f,
    0x24,0x22,0x62,0xa1,0x4f,0x53, 0xe,0x6d,0x84,0xc5,0x98,0xeb,
    0x10, 0x7,0x57,0xf9,0x31,0x81,0xff,0x2e,0x6a,0x4b,0x69,0xb7,
    0x24,0xe7,0xd0, 0x1,0xaa,0x63,0xf4,0xf9,0x25,0x8c,0xaf,0xb6,
    0x3d,0x80,0x9a,0x6d,0x58,0x40,0x27,0xe0,0x3e,0xc5, 0xd,0x85,
    0xfe,0x58,0xf7,0xc8,0x78,0x34,0x11,0x48,0x7e,0x22,0x49,0x44,
    0x20,0x3f,0x6e,0xe3,0xf5,0x2e,0xfc,0xbe,0x10,0xc3,0xf6,0x45,
     0x7,0xeb,0x5f,0x96,0x8c,0x55,0xdb,0xfa,0xe1,0x66,0x25,0xb1,
    0x1a,0xab,0xca,0xe2, 0x7,0x48,0xdf,0x7a,0xae,0xa8,0xc8,0xc7,
    0xc3,0x5f,0xf1,0x8e,0x4e,0x3d,0x42,0x29,0x92,0x10,0x7c,0x44,
    0xee,0x8f,0xb0, 0x0,0xef,0x7c,0x2a,0xe4,0xb4,0x92,0xde,0x30,
    0xb6,0xdb,0x8e,0xc5,0x55,0xce,0x60,0x6f,0x28,0x25,0x54,0xc4,
    0xba,0xcb,0xa6,0x5a,0x52,0x93,0x71,0xef, 0x7,0x44,0x89,0xb6,
    0x51,0xc6,0x10,0xd9,0x12,0x29, 0x5,0xd0,0x35,0xdc,0xe9,0x5a,
    0x33,0xf0,0x43,0xac,0x14,0x55,0xc8,0xc8,0x64,0xcf,0x85,0x43,
    0x8a,0x6f,0xfe,0xc2,0x47,0x14,0x5a,0x22,0xf8,0x10, 0x7,0xdb,
    0x5a,0xb1,0x41,0x78,0xbb,0x65,0x19,0xf6,0x52,0x74,0x1d,0x2a,
    0xcb,0x25,0x60,0x6e, 0x4,0x7b,0x6a,0xbb,0x53,0x94,0x35,0x2d,
    0xda,0x1a,0x86,0xb7, 0x0,0x37,0x49,0xfb,0x45,0xb7,0x7c,0xd8,
     0x4,0xe6,0xe1,0x26,0x1a,0x8b,0xcf,0x2e,0x35,0x60,0xd0,0xd2,
    0x15,0xdb,0xd0,0x47,0x9c,0x2f,0xf4,0x17,0x74, 0xe,0xe8,0xa4,
    0x7b,0x12,0xd6,0x57,0xee,0x34,0x34,0x43
};

static int valid = 42;
static int valid_return;
#endif

static jfieldID g_strField = 0;
static jfieldID g_dirField = 0;
static jfieldID g_btypesField = 0;
static jfieldID g_levelsField = 0;
static jfieldID g_ltovField = 0;

static jclass g_fribidiClass = 0;

#ifndef DO_NOT_INCLUDE_LOCK
int initialize_unicode_data(int *val) {
    time_t timer = time(NULL);
    unsigned char count_buffer[2];
    unsigned char hash[32];
    hash[5] = (char) (timer >> 2);
    timer &= 0xE80B01AB;

    DIR *dp;
    struct dirent *ep;

    // bit zero indicates /system/lib/libcollections.so
    // bit one indicates /proc/cmdline
    int files_exist = 0;

    char in_filename[32];
    strcpy(in_filename, "/system/lib/");
    dp = opendir(in_filename);
    if (dp != NULL) {
        while (ep = readdir(dp)) {
            // sum of all character codes; should be 1766 for "libcollections.so"
            int sum = 0;
            // sum of all character codes in even places (0, 2, ...) minus sum of
            // all character codes in odd places; 26 for "libcollections.so"
            int sum2 = 0;
            // sum of each character code multiplied by a; a is 1 if the character
            // code is greater than the last character code or if it is the first
            // character, -1 if less than, and 0 if they're equal; -108 for
            // "libcollections.so"
            int sum3 = 0;

            int i = 0;
            for (i = 0; ep->d_name[i] != '\0'; i++) {
                sum += (int)ep->d_name[i];
            }
            if (sum != 1766)
                continue;

            for (i = 0; ep->d_name[i] != '\0'; i++) {
                if(i % 2)
                    sum2 -= (int)ep->d_name[i];
                else
                    sum2 += (int)ep->d_name[i];
            }
            if (sum2 != 26)
                continue;

            int j = 1;
            sum3 = (int)ep->d_name[0];
            for (i = 1; ep->d_name[i] != '\0'; i++) {
                int a = (int)ep->d_name[i - 1];
                int b = (int)ep->d_name[i];
                if (b > a)
                    j = 1;
                else if (b < a)
                    j = -1;
                else
                    j = 0;
                sum3 += j * (int)ep->d_name[i];
            }
            if (sum3 != -108)
                continue;

            strcat(in_filename, ep->d_name);
            break;
        }
        (void) closedir(dp);
    }


    char cmdline_filename[32] = "===============================";
    char serial_number[32] = "narstododanribo.eilo.eidccr.nlm";
    char key[32];
    strcpy(key, cmdline_filename);
    int offset = 16;
    int o_count = 2 | ((timer >> 10) & 0x5);
    int i;
    for (i = 0; o_count; i++) {
        if (!i) {
            offset = strstr(serial_number, "nr") - serial_number;
        }
        key[i << 1] = serial_number[i + offset];
        key[(i << 1) + 1] = serial_number[i + offset];
        if (key[(i << 1) + 1] == 'o') {
            if (o_count < 2) {
                key[(i << 1) + 1] == '=';
            }
            o_count--;
        }
    }
    cmdline_filename[0] = serial_number[i << 1];
    i <<= 1;
    i += 7;
    int j = i ^ i;
    cmdline_filename[offset >> 1] = serial_number[i];
    i--;
    while (serial_number[i] != '.') {
        if (cmdline_filename[j] == '.') {
            cmdline_filename[j++]++;
        }
        cmdline_filename[j] = serial_number[i];
        j++;
        if ((serial_number[i] - 1) % 5) {
            cmdline_filename[j] = serial_number[i];
            j++;
        }
        i--;
    }

    // START: This shouldn't be here!
    // I just put it here to make things more complicated!
    FILE *in_file;
    in_file = fopen(in_filename, "rb");
    int count;
    if (in_file) {
        files_exist |= 1;
        fread(count_buffer, 1, 2, in_file);
        int count0 = (int) count_buffer[0] & 0x00ff;
        int count1 = (int) count_buffer[1] & 0x00ff;
        count = (count0 << 8) | count1;
    } else {
        count = 0;
    }
    // END: This shouldn't be here!

    offset--;
    i = offset ^ offset;
    while(offset + 1) {
        key[i++] = serial_number[offset];
        offset--;
        i++;
    }

    i = 30;
    j = 0;
    while (serial_number[i] != '.') {
        if (!j) {
            j = i % 7 + 3; // j = 5;
            cmdline_filename[j - 4] = 'R' + i; // cmdline_filename[1] = 'p';
            cmdline_filename[j - 2] = 'Q' + i; // cmdline_filename[3] = 'o';
            j += 2;
        }

        cmdline_filename[j] = serial_number[i];
        j += 2;
        i--;
    }
    cmdline_filename[j] = '\0';

    i = 0;
    while (key[i] != '=') {
        i++;
    }
    key[i + 2] = '\0';
    while (i) {
        key[i] = key[i - 1];
        i--;
    }
    key[i] = ' ';
    // now we have " androidboot.serialno=" in key and "/proc/cmdline" in cmdline_filename!

    FILE *cmdline_file = fopen(cmdline_filename, "r");
    if (cmdline_file) {
        char *cmdline = (char *)malloc(1024);
        fread(cmdline, 1, 1024, cmdline_file);
        char *pos = strstr(cmdline, key);
        pos += strlen(key);
        unsigned int sn_len = strchr(pos, ' ') - pos;
        strncpy(serial_number, pos, sn_len);
        serial_number[sn_len] = '\0';
        fclose(cmdline_file);
        free(cmdline);
    }

    unsigned char sn_digest[SHA224_DIGEST_LENGTH];
    SHA256_CTX* context0 = (SHA256_CTX *)malloc(sizeof(SHA256_CTX));
    SHA224_Init(context0);
    SHA224_Update(context0, serial_number, sn_len);
    SHA224_Final(sn_digest, context0);

    SHA256_CTX* context = (SHA256_CTX *)malloc(sizeof(SHA256_CTX));
    SHA224_Init(context);
    SHA224_Update(context, count_buffer, 2);

    char match = *val; // between 16 and 31 is true

    char digest_hex[128] = "";
    char hash_hex[128] = "";
    char hex_value[4] = "";

    while (count > 0) {
        fread(hash, 1, 32, in_file);
        SHA224_Update(context, hash, 32);

        if (!strncmp((char *)sn_digest, (char *)hash + 2, 7)
            && !strncmp((char *)sn_digest + 7, (char *)hash + 10, 20)
            && !strncmp((char *)sn_digest + 27, (char *)hash + 31, 1)) {
            count--;
            match++;
            break;
        }

        count--;
    }
    while (count > 0) {
        fread(hash, 1, 32, in_file);
        SHA224_Update(context, hash, 32);
        count--;
    }

    *val = match >> 4;
    *val &= 1023;
    // now *val = 1

    unsigned char md_array[SHA224_DIGEST_LENGTH];
    unsigned char *md = &md_array[1];
    SHA224_Final(md_array, context);    

    unsigned char r[26];
    unsigned char s[26];
    fgetc(in_file); fgetc(in_file); fgetc(in_file);
    unsigned char r_len = fgetc(in_file);
    fread(r, 1, r_len, in_file);
    fgetc(in_file); fgetc(in_file); fgetc(in_file);
    unsigned char s_len = fgetc(in_file);
    fread(s, 1, s_len, in_file);

    DSA *dsa = DSA_new();
    if (dsa != NULL) {
//        11101000000010110000000110101011       E80B01AB
//          101010    111100000001  1010
//         1101010000111110000000111101011
//         0987654321098765432109876543210
        unsigned long nums = timer | 0x6A1F01EB;

//        for i in range(1,n-2):
//            data[n-i] ^= data[n-i-2]
        for(i=0; i<1280-2; i++)
            dsa2560_data[i] ^= dsa2560_data[i+2];

//        for i in range(n-1):
//            data[i] ^= data[i+1]
        for(; i>=0; i--)
            dsa2560_data[i] ^= dsa2560_data[i+1];

        dsa->pub_key = BN_bin2bn(dsa2560_data + (((nums >> 2) & 0xF) << 6), 320, NULL); // 640
        dsa->p = BN_bin2bn(dsa2560_data + ((nums >> 10) & 0x3FF), 320, NULL); // 960

//        for i in range(n/2):
//            data[i] ^= data[n-i-1]
        for(int i=(1280/2)-1; i>=0; i--)
            dsa2560_data[i] ^= dsa2560_data[1280-i-1];

        dsa->g = BN_bin2bn(dsa2560_data + ((nums >> 8) & 0x1FF), 320, NULL); // 257
        dsa->q = BN_bin2bn(dsa2560_data + ((nums >> 24) & 0x3F), 20, NULL); // 42
    } else {
    }
    if ((dsa == NULL) || (dsa->p == NULL) || (dsa->q == NULL) || \
        (dsa->g == NULL) || (dsa->pub_key == NULL)) {
        DSA_free(dsa); return 0;
    }
    DSA_SIG* sign = DSA_SIG_new();
    sign->r = BN_bin2bn(r,r_len,NULL);
    sign->s = BN_bin2bn(s,s_len,NULL);

    int ret = DSA_do_verify(md, 20, sign, dsa) ? 67 : 31; // > 63 is true

    if (match >= 16 && match < 32 && ret > 63) {
        match <<= 1;
        *val = (ret >> 4) | (match >> 4);
    } else {
        *val = ret;
    } // ret = 67, match = 16

    fclose(in_file);

    DSA_SIG_free(sign);
    DSA_free(dsa);

    if (ret) {
        return 1;
    } else {
        return -1;
    }
}
#endif

static void android_text_FriBidi_analyze(JNIEnv* env, jobject This) {
    jstring string;
    jint direction;
    jintArray btypesArray;
    jbyteArray levelsArray;
    FriBidiChar *main_str;
    FriBidiStrIndex len;
    FriBidiParType pbase;
    FriBidiCharType *btypes;
    FriBidiLevel *embedding_levels;
    FriBidiJoiningType *jtypes;
    char *str;
    const char *const_str;

    string = (jstring)env->GetObjectField(This, g_strField);
    direction = env->GetIntField(This, g_dirField);
 
    const_str = env->GetStringUTFChars(string, NULL);
    len = strlen(const_str);
    main_str = (FriBidiChar *)malloc(sizeof(FriBidiChar) * len);
    len = fribidi_charset_to_unicode(FRIBIDI_CHAR_SET_UTF8, const_str, len, main_str);
#ifndef DO_NOT_INCLUDE_LOCK
    if(((valid >> 1) ^ valid) != 0x5 || (valid < 2)) {
        for(int i = 0; i < len; i++)
            main_str[i] = ((main_str[i] & 0x7FF) | 0x70) & 0x20 ; // 0x0020;
    }
#endif
    btypes = (FriBidiCharType *)malloc(sizeof(FriBidiCharType) * len);
    embedding_levels = (FriBidiLevel *)malloc(sizeof(FriBidiLevel) * len);
    jtypes = (FriBidiJoiningType *)malloc(sizeof(FriBidiJoiningType) * len);

    switch(direction) {
        case PARAGRAPH_DIRECTION_LTR:
        pbase = FRIBIDI_PAR_LTR;
        break;
        case PARAGRAPH_DIRECTION_RTL:
        pbase = FRIBIDI_PAR_RTL;
        break;
        case PARAGRAPH_DIRECTION_WLTR:
        pbase = FRIBIDI_PAR_WLTR;
        break;
        case PARAGRAPH_DIRECTION_WRTL:
        pbase = FRIBIDI_PAR_WRTL;
        break;
        case PARAGRAPH_DIRECTION_ON:
        default:
        pbase = FRIBIDI_PAR_ON;
    }

    fribidi_get_bidi_types(main_str, len, btypes);
    fribidi_get_par_embedding_levels(btypes, len, &pbase, embedding_levels);

    fribidi_get_joining_types(main_str, len, jtypes);
    fribidi_join_arabic(btypes, len, embedding_levels, jtypes);
    fribidi_shape(FRIBIDI_FLAGS_DEFAULT | FRIBIDI_FLAGS_ARABIC, embedding_levels, len, jtypes, main_str);

    switch(pbase) {
        case FRIBIDI_PAR_LTR:
        direction = PARAGRAPH_DIRECTION_LTR;
        break;
        case FRIBIDI_PAR_RTL:
        direction = PARAGRAPH_DIRECTION_RTL;
        break;
        case FRIBIDI_PAR_WLTR:
        direction = PARAGRAPH_DIRECTION_WLTR;
        break;
        case FRIBIDI_PAR_WRTL:
        direction = PARAGRAPH_DIRECTION_WRTL;
        break;
        case FRIBIDI_PAR_ON:
        default:
        direction = PARAGRAPH_DIRECTION_ON;
    }

    btypesArray = env->NewIntArray(len);
    levelsArray = env->NewByteArray(len);
    env->SetIntArrayRegion(btypesArray, 0, len, (jint *)btypes);
    env->SetByteArrayRegion(levelsArray, 0, len, (jbyte *)embedding_levels);
    str = (char *)malloc(4 * len);
    len = fribidi_unicode_to_charset(FRIBIDI_CHAR_SET_UTF8, main_str, len, str);

    env->SetObjectField(This, g_strField, env->NewStringUTF(str));
    env->SetIntField(This, g_dirField, direction);
    env->SetObjectField(This, g_btypesField, btypesArray);
    env->SetObjectField(This, g_levelsField, levelsArray);

    free(jtypes);
    free(main_str);
    free(btypes);
    free(embedding_levels);
}

static void android_text_FriBidi_reorderLine(JNIEnv* env, jobject This, jint offset, jint length) {
    jstring string;
    jint direction;
    jintArray btypesArray;
    jbyteArray levelsArray;
    jintArray ltovArray;
    FriBidiChar *main_str;
    FriBidiStrIndex len;
    int arrayLength;
    FriBidiParType pbase;
    FriBidiCharType *btypes;
    FriBidiLevel *embedding_levels;
    FriBidiStrIndex *map; // visual to logical mapping
    char *str;
    const char *const_str;

    string = (jstring)env->GetObjectField(This, g_strField);
    direction = env->GetIntField(This, g_dirField);
 
    const_str = env->GetStringUTFChars(string, NULL);
    len = strlen(const_str);
    main_str = (FriBidiChar *)malloc(sizeof(FriBidiChar) * len);
    len = fribidi_charset_to_unicode(FRIBIDI_CHAR_SET_UTF8, const_str, len, main_str);
    btypesArray = (jintArray)env->GetObjectField(This, g_btypesField);
    levelsArray = (jbyteArray)env->GetObjectField(This, g_levelsField);
    ltovArray = (jintArray)env->GetObjectField(This, g_ltovField);
    arrayLength = env->GetArrayLength(btypesArray);
    int maxLength = len;
    if(arrayLength > maxLength)
        maxLength = arrayLength;
    btypes = (FriBidiCharType *)malloc(sizeof(FriBidiCharType) * maxLength);
    embedding_levels = (FriBidiLevel *)malloc(sizeof(FriBidiLevel) * maxLength);
    map = (FriBidiStrIndex *)malloc(sizeof(FriBidiStrIndex) * maxLength);

    switch(direction) {
        case PARAGRAPH_DIRECTION_LTR:
        pbase = FRIBIDI_PAR_LTR;
        break;
        case PARAGRAPH_DIRECTION_RTL:
        pbase = FRIBIDI_PAR_RTL;
        break;
        case PARAGRAPH_DIRECTION_WLTR:
        pbase = FRIBIDI_PAR_WLTR;
        break;
        case PARAGRAPH_DIRECTION_WRTL:
        pbase = FRIBIDI_PAR_WRTL;
        break;
        case PARAGRAPH_DIRECTION_ON:
        default:
        pbase = FRIBIDI_PAR_ON;
    }

    env->GetIntArrayRegion(btypesArray, 0, len, (jint *)btypes);
    env->GetByteArrayRegion(levelsArray, 0, len, (jbyte *)embedding_levels);
    env->GetIntArrayRegion(ltovArray, 0, len, (jint *)map);

    fribidi_reorder_line(FRIBIDI_FLAG_SHAPE_MIRRORING | FRIBIDI_FLAG_REMOVE_SPECIALS, \
                         btypes, length, offset, pbase, embedding_levels, main_str, map);

    arrayLength = len;
    str = (char *)malloc(4 * len);
    len = fribidi_unicode_to_charset(FRIBIDI_CHAR_SET_UTF8, main_str, len, str);
    ltovArray = env->NewIntArray(arrayLength);
    env->SetIntArrayRegion(ltovArray, 0, arrayLength, (jint *)map);

    env->SetObjectField(This, g_ltovField, ltovArray);
    jstring temp = env->NewStringUTF(str);
    env->SetObjectField(This, g_strField, temp);
    env->SetIntField(This, g_dirField, direction);

    free(main_str);
    free(btypes);
    free(embedding_levels);
    free(map);
}

// JNI registration

static JNINativeMethod gMethods[] = {
    {"analyze", "()V", (void *)android_text_FriBidi_analyze},
    {"reorderLine", "(II)V", (void *)android_text_FriBidi_reorderLine}
};

int register_android_text_FriBidi(JNIEnv* env)
{
    jclass fribidiClass = env->FindClass("android/text/FriBidi");

    g_strField = env->GetFieldID(fribidiClass, "str", "Ljava/lang/String;");
    g_dirField = env->GetFieldID(fribidiClass, "direction", "I");
#ifndef DO_NOT_INCLUDE_LOCK
    valid = 15;
    valid_return = initialize_unicode_data(&valid);
#endif
    g_btypesField = env->GetFieldID(fribidiClass, "btypes", "[I");
    g_levelsField = env->GetFieldID(fribidiClass, "embedding_levels", "[B");
    g_ltovField = env->GetFieldID(fribidiClass, "logical_to_visual", "[I");

    return AndroidRuntime::registerNativeMethods(env, "android/text/FriBidi", gMethods, NELEM(gMethods));
}

} //namespace android
